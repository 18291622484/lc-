int main() {
    ////使用这种方式来重命名数据类型，这样可以很方便的修改后续数据的数据类型，相当于#define的作用
    //typedef int StackType;
    ////创建栈
    //typedef struct Stack {
    //    //使用指针指向一块动态开辟的内存
    //    StackType* _date;
    //    //表示栈中的有效数据，也代表了栈顶
    //    size_t _size;
    //    //表示栈的最大容量
    //    size_t _capacity;
    //}Stack;

    ////包含所有函数的声明
    ////栈初始化
    //void StackInit(Stack * s1);
    ////检查栈是否已满
    //void CheckCapacity(Stack * s1);
    ////进栈
    //void StackPush(Stack * s1, StackType val);
    ////出栈 
    //void StackPop(Stack * s1);
    //// 获取栈顶元素
    //StackType StackTop(Stack * s1);
    //// 获取栈中有效元素个数
    //int StackSize(Stack * s1);
    ////###########################################################################################

    ////栈初始化
    //void StackInit(Stack * s1) {
    //    //参数合法性检验
    //    if (s1 == NULL) {
    //        return;
    //    }
    //    s1->_date = NULL;
    //    s1->_capacity = s1->_size = 0;
    //}

    ////检查栈是否已满
    //void CheckCapacity(Stack * s1) {
    //    //该函数是在其他函数内部被调用的，所以就不用参数合法性检验了，因为前面已经检查过了
    //    //如果有效数据等于最大容量，那么需要增容
    //    if (s1->_capacity == s1->_size) {
    //        //每次以2倍的空间进行增容
    //        s1->_capacity = s1->_capacity == 0 ? 1 : 2 * s1->_capacity;
    //        //用realloc函数进行动态增容
    //        s1->_date = (StackType*)realloc(s1->_date, sizeof(StackType) * s1->_capacity);
    //    }
    //}

    ////进栈
    //void StackPush(Stack * s1, StackType val) {
    //    //参数合法性检验
    //    if (s1 == NULL) {
    //        return;
    //    }
    //    //检查容量是否够，不够的话就增容
    //    CheckCapacity(s1);
    //    s1->_date[s1->_size] = val;
    //    s1->_size++;
    //}

    ////出栈 
    //void StackPop(Stack * s1) {
    //    //参数合法性检验,如果没有数据就直接返回
    //    if (s1 == NULL || s1->_size == 0) {
    //        return;
    //    }
    //    //这是顺序表，所以不用像链表一样，删除一个数据就要释放一个空间，只需有效数据个数减一即可
    //    s1->_size--;
    //}

    //// 获取栈顶元素
    //StackType StackTop(Stack * s1) {
    //    //参数合法性检验不好做，因为不能以任何值作为出错的返回值，以后学了抛出异常就可解决
    //    return s1->_date[s1->_size - 1];
    //}

    //// 获取栈中有效元素个数
    //int StackSize(Stack * s1) {
    //    //参数合法性检验
    //    if (s1 == NULL) {
    //        return 0;
    //    }
    //    return s1->_size;
    //}

    ////###########################################################################################
    ////###########################################################################################



    ////使用栈，不创建地图做法调用的函数
    //char ret(char c) {
    //    if (c == ')') {
    //        return '(';
    //    }
    //    if (c == '}') {
    //        return '{';
    //    }
    //    if (c == ']') {
    //        return '[';
    //    }
    //    return 0;
    //}

    //bool isValid(char* s) {
    //    if (!strlen(s)) {
    //        return true;
    //    }
    //    if (strlen(s) % 2 == 1) {
    //        return false;
    //    }


    //    使用栈，不创建地图
    //        Stack s1;
    //    StackInit(&s1);
    //    while (*s) {
    //        if (*s == '(' || *s == '{' || *s == '[') {
    //            StackPush(&s1, *s);
    //            s++;
    //        }
    //        else {
    //            if (StackSize(&s1) == 0) {
    //                return false;
    //            }
    //            if (StackTop(&s1) == ret(*s)) {
    //                StackPop(&s1);
    //                s++;
    //            }
    //            else {
    //                return false;
    //            }
    //        }
    //    }
    //    return StackSize(&s1) == 0;



    //    //使用栈，创建地图
    //    Stack s1;
    //    StackInit(&s1);
    //    static char map[][2] = { {'(' , ')'} , {'{' , '}'} , {'[' , ']'} };
    //    while (*s) {
    //        if (*s == '(' || *s == '{' || *s == '[') {
    //            StackPush(&s1, *s);
    //            s++;
    //        }
    //        else {
    //            if (StackSize(&s1) == 0) {
    //                return false;
    //            }
    //            for (int i = 0; i < 3; i++) {
    //                if (*s == map[i][1]) {
    //                    if (StackTop(&s1) == map[i][0]) {
    //                        StackPop(&s1);
    //                        s++;
    //                        break;
    //                    }
    //                    else {
    //                        return false;
    //                    }
    //                }
    //            }
    //        }
    //    }
    //    return StackSize(&s1) == 0;
    //}
	return 0;
}